// GUID: SCRIPT_GENERATE_ERROR_REGISTRY-000-v03
// [Intent] Reads the enriched code.json and generates two files:
//   1. src/lib/error-registry.ts  -- typed ERRORS constants (one per errorProfile.emits entry)
//   2. ../code-index.json         -- lightweight lookup index (byErrorCode, byTopic, byModule, byFile)
//   These generated files provide instant lookup for the traced-error system.
// [Inbound Trigger] Run manually via: npx ts-node scripts/generate-error-registry.ts
//   or: npx tsx scripts/generate-error-registry.ts
// [Downstream Impact] error-registry.ts is imported by all catch blocks via ERRORS.XXX.
//   code-index.json is consulted by Claude Code for instant error lookup.

import * as fs from 'fs';
import * as path from 'path';

const PROJECT_ROOT = path.resolve(__dirname, '..', '..');
const CODE_JSON_PATH = path.join(PROJECT_ROOT, 'code.json');
const REGISTRY_OUTPUT = path.join(__dirname, '..', 'src', 'lib', 'error-registry.ts');
const INDEX_OUTPUT = path.join(PROJECT_ROOT, 'code-index.json');

interface EmitEntry {
  key: string;
  message: string;
  severity: string;
  recovery: string;
  failureModes: string[];
}

interface ErrorProfile {
  throws: string[];
  handles: string[];
  emits: Record<string, EmitEntry>;
}

interface CallChain {
  calledBy: string[];
  calls: string[];
}

interface Location {
  filePath: string;
  functionName?: string;
}

interface GuidEntry {
  guid: string;
  version: number;
  logic_category: string;
  description: string;
  dependencies: string[];
  location?: Location;
  errorProfile?: ErrorProfile;
  callChain?: CallChain;
  security_notes?: string;
}

interface CodeJson {
  module: string;
  generated: string;
  total_guids: number;
  guids: GuidEntry[];
}

function extractModule(guid: string): string {
  const lastDash = guid.lastIndexOf('-');
  if (lastDash === -1) return guid;
  const suffix = guid.substring(lastDash + 1);
  if (/^\d+$/.test(suffix)) {
    return guid.substring(0, lastDash);
  }
  return guid;
}

function main() {
  console.log('Reading code.json...');
  const codeJson: CodeJson = JSON.parse(fs.readFileSync(CODE_JSON_PATH, 'utf-8'));

  // ── Build error registry ──────────────────────────────────────────
  const errors: Array<{
    key: string;
    code: string;
    guid: string;
    module: string;
    file: string;
    functionName: string;
    message: string;
    severity: string;
    recovery: string;
    failureModes: string[];
    calledBy: string[];
    calls: string[];
  }> = [];

  // Collect all unique error definitions from emits
  const seenKeys = new Set<string>();

  for (const entry of codeJson.guids) {
    if (!entry.errorProfile?.emits) continue;

    const module = extractModule(entry.guid);
    const file = entry.location?.filePath ?? 'UNKNOWN';
    const functionName = entry.location?.functionName ?? '';
    const calledBy = entry.callChain?.calledBy ?? [];
    const calls = entry.callChain?.calls ?? [];

    for (const [code, emit] of Object.entries(entry.errorProfile.emits)) {
      // Use a composite key to deduplicate: code + guid
      // But for the registry, we want one entry per error key
      if (!emit.key || seenKeys.has(emit.key)) continue;
      seenKeys.add(emit.key);

      errors.push({
        key: emit.key,
        code,
        guid: entry.guid,
        module,
        file,
        functionName,
        message: emit.message,
        severity: emit.severity,
        recovery: emit.recovery || '',
        failureModes: emit.failureModes || [],
        calledBy,
        calls,
      });
    }
  }

  // Sort by error code for consistent output
  errors.sort((a, b) => a.code.localeCompare(b.code));

  // Generate error-registry.ts
  const registryLines: string[] = [
    '// AUTO-GENERATED by scripts/generate-error-registry.ts — DO NOT EDIT',
    `// Generated: ${new Date().toISOString().split('T')[0]}`,
    `// Source: code.json (${codeJson.guids.length} GUIDs)`,
    '',
    "import type { ErrorDefinition } from '@/types/errors';",
    '',
    '/**',
    ' * Typed error definitions sourced from code.json errorProfile.emits.',
    ' * Every catch block should use ERRORS.KEY_NAME to create traced errors.',
    ' */',
    'export const ERRORS: Record<string, ErrorDefinition> = {',
  ];

  for (const err of errors) {
    registryLines.push(`  ${err.key}: {`);
    registryLines.push(`    key: '${err.key}',`);
    registryLines.push(`    code: '${err.code}',`);
    registryLines.push(`    guid: '${err.guid}',`);
    registryLines.push(`    module: '${err.module}',`);
    registryLines.push(`    file: '${escapeStr(err.file)}',`);
    registryLines.push(`    functionName: '${escapeStr(err.functionName)}',`);
    registryLines.push(`    message: '${escapeStr(err.message)}',`);
    registryLines.push(`    severity: '${err.severity}',`);
    registryLines.push(`    recovery: '${escapeStr(err.recovery)}',`);
    registryLines.push(`    failureModes: [${err.failureModes.map(f => `'${escapeStr(f)}'`).join(', ')}],`);
    registryLines.push(`    calledBy: [${err.calledBy.map(c => `'${c}'`).join(', ')}],`);
    registryLines.push(`    calls: [${err.calls.map(c => `'${c}'`).join(', ')}],`);
    registryLines.push('  },');
  }

  registryLines.push('} as const;');
  registryLines.push('');

  fs.writeFileSync(REGISTRY_OUTPUT, registryLines.join('\n'));
  console.log(`Generated ${REGISTRY_OUTPUT} with ${errors.length} error definitions.`);

  // ── Build code-index.json ─────────────────────────────────────────
  const byErrorCode: Record<string, {
    guid: string;
    file: string;
    function: string;
    message: string;
    recovery: string;
  }> = {};

  const byTopic: Record<string, string[]> = {};
  const byModule: Record<string, { files: string[]; errorCodes: string[] }> = {};
  const byFile: Record<string, { modules: string[]; errorCodes: string[] }> = {};

  for (const entry of codeJson.guids) {
    const module = extractModule(entry.guid);
    const file = entry.location?.filePath ?? 'UNKNOWN';

    // byModule
    if (!byModule[module]) {
      byModule[module] = { files: [], errorCodes: [] };
    }
    if (file !== 'UNKNOWN' && !byModule[module].files.includes(file)) {
      byModule[module].files.push(file);
    }

    // byFile
    if (file !== 'UNKNOWN') {
      if (!byFile[file]) {
        byFile[file] = { modules: [], errorCodes: [] };
      }
      if (!byFile[file].modules.includes(module)) {
        byFile[file].modules.push(module);
      }
    }

    // byErrorCode + collect error codes for module/file
    if (entry.errorProfile?.emits) {
      for (const [code, emit] of Object.entries(entry.errorProfile.emits)) {
        byErrorCode[code] = {
          guid: entry.guid,
          file,
          function: entry.location?.functionName ?? '',
          message: emit.message,
          recovery: emit.recovery || '',
        };

        if (!byModule[module].errorCodes.includes(code)) {
          byModule[module].errorCodes.push(code);
        }
        if (file !== 'UNKNOWN' && byFile[file] && !byFile[file].errorCodes.includes(code)) {
          byFile[file].errorCodes.push(code);
        }
      }
    }

    // byTopic -- extract keywords from description and module name
    const topicWords = extractTopics(module, entry.description);
    for (const topic of topicWords) {
      if (!byTopic[topic]) byTopic[topic] = [];
      if (!byTopic[topic].includes(entry.guid)) {
        byTopic[topic].push(entry.guid);
      }
    }
  }

  const codeIndex = {
    generated: new Date().toISOString().split('T')[0],
    totalGuids: codeJson.guids.length,
    totalErrorCodes: Object.keys(byErrorCode).length,
    byErrorCode,
    byTopic,
    byModule,
    byFile,
  };

  fs.writeFileSync(INDEX_OUTPUT, JSON.stringify(codeIndex, null, 2));
  console.log(`Generated ${INDEX_OUTPUT} with ${Object.keys(byErrorCode).length} error codes, ${Object.keys(byTopic).length} topics, ${Object.keys(byModule).length} modules, ${Object.keys(byFile).length} files.`);
}

function escapeStr(s: string): string {
  return s.replace(/\\/g, '\\\\').replace(/'/g, "\\'");
}

function extractTopics(module: string, description: string): string[] {
  const topics = new Set<string>();

  // Module-derived topics
  const moduleLower = module.toLowerCase();
  if (moduleLower.includes('backup')) topics.add('backup');
  if (moduleLower.includes('scoring') || moduleLower.includes('score')) topics.add('scoring');
  if (moduleLower.includes('auth') || moduleLower.includes('login')) topics.add('login');
  if (moduleLower.includes('email')) topics.add('email');
  if (moduleLower.includes('attack')) topics.add('attack');
  if (moduleLower.includes('prediction')) topics.add('prediction');
  if (moduleLower.includes('admin')) topics.add('admin');
  if (moduleLower.includes('consistency')) topics.add('consistency');
  if (moduleLower.includes('league')) topics.add('league');
  if (moduleLower.includes('team')) topics.add('team');
  if (moduleLower.includes('standing')) topics.add('standings');
  if (moduleLower.includes('result')) topics.add('results');
  if (moduleLower.includes('schedule')) topics.add('schedule');
  if (moduleLower.includes('dashboard')) topics.add('dashboard');
  if (moduleLower.includes('whatsapp')) topics.add('whatsapp');
  if (moduleLower.includes('audit')) topics.add('audit');
  if (moduleLower.includes('feedback')) topics.add('feedback');
  if (moduleLower.includes('profile')) topics.add('profile');
  if (moduleLower.includes('sidebar')) topics.add('sidebar');
  if (moduleLower.includes('error')) topics.add('error');
  if (moduleLower.includes('firebase')) topics.add('firebase');
  if (moduleLower.includes('provider')) topics.add('auth');
  if (moduleLower.includes('oauth')) topics.add('oauth');
  if (moduleLower.includes('recovery') || moduleLower.includes('smoke')) topics.add('recovery');

  // Description-derived topics
  const descLower = (description || '').toLowerCase();
  if (descLower.includes('smoke test')) topics.add('smoke');
  if (descLower.includes('verification')) topics.add('verification');
  if (descLower.includes('race result')) topics.add('results');
  if (descLower.includes('signup') || descLower.includes('sign up')) topics.add('signup');
  if (descLower.includes('pin')) topics.add('pin');
  if (descLower.includes('deadline')) topics.add('deadline');

  return Array.from(topics);
}

main();
